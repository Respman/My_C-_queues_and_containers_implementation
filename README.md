# Queues_and_containers_implementation

Моя реализация некоторых видов контейнеров и очередей на языке C++

## Очередь с приоритетом 

Реализован контейнер-адаптер priority_queue.

*Принцип работы очереди:* первым извлекается наибольший элемент.

Контейнер должен обеспечивать логарифмическое время работы для добавления и удаления элемента. 

Работа состоит из двух файлов: 
* `priority-queue.h` – описание класса priority_queue, прототипы методов, реализация методов 
* `test-queue.cpp` – тестирование и проверка возможностей класса

Список требований к классам:

- класс priority_queue содержит два шаблонных параметра: хранимый тип данных, используемый контейнер (по умолчанию динамический массив стандартной библиотеки) 

- класс priority_queue содержит одно поле — используемый контейнер; 

- хранение элементов организовать в виде двоичной кучи (пирамиды);

- класс должен содержать следующие методы: 
1. проверка очереди на пустоту
2. получение числа элементов в очереди
3. добавление элемента в очередь
4. удаление элемента из очереди
5. доступ к максимальному элементу очереди

## Контейнер map 

Реализован ассоциативный массив (контейнер map) на основе AVL-дерева поиска. Каждый узел двоичного дерева содержит пару ключ-значение. 

Особенностью данной реализации являются полностью итеративные функции.

Пользователь имеет возможность:
1. получить значение по ключу
2. изменить значение по ключу
3. добавить в контейнер новую пару 

Работа состоит из двух основных файлов: 
* `map.h` – описание класса map, прототипы методов, реализация методов
* `test-map.cpp` – тестирование и проверка возможностей класса

Список требований к классам:

- создать вспомогательную шаблонную структуру node, содержащую поле 
для хранения значения произвольного типа и 3 поля для хранения указателей на родителя и левого/правого потомков; 
- класс map содержит три шаблонных параметра: 
1. тип ключа 
2. тип значения 
3. тип критерия сравнения
- каждый узел дерева в поле данных содержит пару ключ-значение;
- класс map содержит одно поле – указатель на узел, являющийся корнем дерева. 
- класс map должен содержать следующие методы: 
1. конструктор, деструктор; 
2. конструктор копирования; 
3. копирующий оператор присваивания; 
4. проверка на пустоту; 
5. удаление всех элементов; 
6. добавление пары ключ-значение; 
7. оператор[] или соотв. метод – получает ключ, возвращает ссылку на значение; 
8. поиск по ключу – возвращает логическое значение или итератор;


## Контейнер btree_map 

Реализован ассоциативный массив (контейнер btree_map) на основе B-дерева. Каждый узел дерева содержит набор пар ключ-значение.

Пользователь имеет возможность: 
1. получить значение по ключу
2. изменить значение по ключу
3. добавить в контейнер новую пару 

Работа состоит из двух основных файлов: 
* `btree_map.h` – описание класса btree_map, прототипы методов, реализация методов 
* `test-map.cpp` – тестирование и проверка возможностей класса

Список требований к классам:

- создать вспомогательную шаблонную структуру node, содержащую два поля (контейнер с парами {ключ, значение}, контейнер с указателями на дочерние структуры node); 
- класс btree_map содержит три шаблонных параметра:
1. тип ключа
2. тип значения
3. тип критерия сравнения
- класс btree_map содержит два поля (указатель на узел, являющийся корнем дерева; параметр t ≥ 2); 
- класс btree_map должен содержать следующие методы:
1. конструктор, деструктор; 
2. конструктор копирования; 
3. копирующий оператор присваивания; 
4. проверка на пустоту; 
5. удаление всех элементов; 
6. добавление пары ключ-значение; 
7. оператор[] или соотв. метод – получает ключ, возвращает ссылку на значение; 
8. поиск по ключу – возвращает логическое значение или итератор; 
- для поиска ключа в структуре node использовать двоичный поиск. 

## Контейнер hash_map 

Реализован ассоциативный массив (контейнер hash_map) на основе хеш-таблицы с разрешением коллизий по методу цепочек. 

Работа состоит из двух файлов: 
* `hash-map.h` – описание класса hash_map, прототипы методов, реализация методов; 
* `test-hash-map.cpp` – тестирование и проверка возможностей класса; 

Список требований к классам:

- класс hash_map содержит три шаблонных параметра:
1. тип ключа K
2. тип значения V
3. тип функции хеширования (по умолчанию стандартная функция используемого языка)

- каждый элемент контейнера – пара ключ-значение; 
- для хранения элементов воспользоваться стандартными контейнерами динамический массив и связный список; 
- класс hash_map содержит следующие поля: 
1. вектор со списками элементов; 
2. число элементов; 
3. число списков; 
4. вещественный коэффициент – максимальный уровень загруженности (по умолчанию равен 2.0); 
- класс hash_map должен содержать следующие методы: 
1. конструктор; 
2. удаление всех элементов; 
3. добавление пары ключ-значение; 
4. оператор[] или соотв. метод – получает ключ, возвращает ссылку на значение; 
5. удаление элемента по ключу; 
6. получение числа элементов; 
7. получение и изменение коэффициента загруженности; 
8. получение текущего уровня загруженности (число всех элементов к числу всех списков); 
9. перехеширование всех элементов; 
- если текущий уровень загруженности превышает максимально допустимый, выполнять перехеширование контейнера, увеличив его размер по формуле `2*size+1`; 
- при добавлении элемента `e` выбирать список по формуле: `hash(e) mod (число списков)`;  
- добавить в метод перехеширования возможность уменьшения числа списков. Если при уменьшении числа списков уровень загруженности превысит максимальный, уменьшить число списков только до максимально допустимого; 
